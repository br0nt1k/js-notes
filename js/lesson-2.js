//Інструкція if
//Інструкція if дозволяє виконати певний блок коду тільки в тому випадку, якщо задана умова істинна (тобто приймає значення true).
//Загальний синтаксис інструкції if виглядає так:
if (condition) {
  // код, який виконується, якщо умова (condition) істинна
}
//Коли інтерпретатор зустрічає інструкцію if, він обчислює вказану умову в круглих дужках (condition), перетворюючи її до логічного типу (boolean).
//Якщо умова (condition) перетворюється до true, виконується блок коду, написаний у фігурних дужках {} — (statement).
//Якщо умова (condition) перетворюється до false, блок коду не виконається і продовжиться виконання програми, що іде після інструкції if.

//У наведених нижче прикладах код перевіряє значення змінної subscription і залежно від нього встановлює значення змінної price.
//Якщо умова перетворюється до true, тобто subscription — це "pro", price встановлюється 100.
let price = 0;
const subscription = "pro";
if (subscription === "pro") {
  price = 100;
}
console.log(price); // 100


//Якщо умова перетворюється до false, код у фігурних дужках не буде виконуватися і price залишиться рівним 0.
let price = 0;
const subscription = "free";
if (subscription === "pro") {
  price = 100;
}
console.log(price); // 0


//Напишемо функцію яка отримує обраний тарифний план у параметрі subscription та повертає його вартість.
function getPrice(subscription) {
  let price = 0;
	
  if (subscription === "pro") {
	price = 100;
  }
	
  return price;
}
console.log(getPrice("free")); // 0	
console.log(getPrice("pro")); // 100

//Функція getPrice працює так:
1) Приймає параметр subscription – рядок, який вказує тип підписки (наприклад, "pro" або "free").

2) Оголошує змінну price і встановлює її значення в 0 за замовчуванням.

3) Перевіряє умову:

Якщо subscription === "pro", то змінній price присвоюється значення 100.
Якщо subscription не "pro", нічого не змінюється, і price залишається 0.
4) Повертає значення price після перевірки.



//Інструкція if...else
//Синтаксис інструкції if можна доповнити блоком else для визначення альтернативних варіантів виконання коду.
if (condition) {
  // код, який виконується, якщо умова істинна
} else {
  // код, який виконується, якщо умова хибна
}


//Створимо функцію яка отримує бал студента, та повертає рішення про результат.
function checkGrade(grade) {
  if (grade >= 70) {
    return "Satisfactory";
  } else {
    return "Unsatisfactory";
  }
}
console.log(checkGrade(40)); // Unsatisfactory
console.log(checkGrade(75)); // Satisfactory
//Функція checkGrade працює так:

1) Вона приймає один параметр – grade, який містить числове значення (оцінку студента).

2) Використовує if...else, щоб перевірити, чи grade більше або дорівнює 70:

Якщо true, повертає "Satisfactory".
Якщо false, повертає "Unsatisfactory".
3) Виклик console.log(checkGrade(40)):

Оскільки 40 < 70, виконується else, тому повертається "Unsatisfactory".
4) Виклик console.log(checkGrade(75)):

Оскільки 75 >= 70, виконується if, тому повертається "Satisfactory".



//Блок else...if
//Конструкція else...if розширює конструкцію if...else і дозволяє перевірити та зреагувати на виконання або невиконання кількох умов. Це корисно, коли ми маємо більше однієї умови.
if (condition_1) {
  // код, який виконується, якщо умова (condition_1) істинна
} else if (condition_2) {
  // код, який виконується, якщо умова (condition_2) істинна
} else if (condition_3) {
  // код, який виконується, якщо умова (condition_3) істинна
} else {
	// код, який виконується, якщо всі умови хибні
}
Кожна умова послідовно перевіряється зверху вниз.
Якщо умова condition_1 істинна, виконується відповідний блок коду, і перевірка завершується.
Якщо умова condition_1 хибна, то перевіряється умова_2 і далі.
Код у блоці else буде виконаний тільки у випадку, якщо жодна з умов у блоках if та else if не є істинною.


//Тернарний оператор
//Тернарний оператор — це коротша синтаксична заміна інструкції if...else. Тернарний оператор дозволяє виконувати певну частину коду залежно від умови.

//< condition > ? <expression if condition is true> : <expression if condition is false>;

//Він працює таким чином:
//обчислюється умова condition;
//якщо умова істинна (перетворюється до true), обчислюється вираз після ?;
//якщо умова хибна (перетворюється до false), обчислюється вираз після :;
//значення обчисленого виразу повертається як результат роботи тернарного оператора.


let type;
const age = 20;

if (age >= 18) {
  type = 'adult';
} else {
  type = 'child';
}
console.log(type); // 'adult'


//Той самий код можна переписати з використанням тернарного оператора:
const age = 20;
const type = age >= 18 ? 'adult' : 'child';
console.log(type); // 'adult'


//Тернарний оператор рекомендується використовувати у найпростіших випадках операції присвоєння чи повернення. Однак не рекомендується використовувати його для складних розгалужень, оскільки це може ускладнити читання та розуміння коду.


//Ось приклад з фукнцією яка порівнює два числа.
function getBiggerNumber(a, b) {
  return a > b ? a : b;
}
console.log(getBiggerNumber(5, 10)); // 10
console.log(getBiggerNumber(20, 15)); // 20
console.log(getBiggerNumber(7, 7)); // 7
Як працює ця функція:

1) Приймає два параметри – a і b.

2) Використовує тернарний оператор (? :), який працює так:

Умова: a > b
Якщо true → повертає a
Якщо false → повертає b
3) Повертає більший із двох чисел.


//Оператор switch
//Оператор switch дозволяє виконувати різні дії залежно від значення виразу. Використання switch є більш компактним і зручним способом для порівняння виразів з кількома варіантами, ніж інструкції if...else та else...if.
//Ось загальний синтаксис оператора switch:
switch (expression) {
  case value1:
    // код, що виконується, якщо вираз (expression) дорівнює value1
    break;
  case value2:
    // код, що виконується, якщо вираз (expression) дорівнює value2
    break;
  // ...
  default:
    // код, що виконується, якщо вираз (expression) не відповідає жодному значенню
}
Як це працює:
Вираз (expression) в операторі switch обчислюється.
Значення виразу порівнюється з кожним блоком case зверху вниз.
Якщо значення виразу відповідає значенню в блоці case, виконується код цього блоку.
Коли виконання коду блоку case завершено, необхідно використовувати оператор break, щоб вийти зі switch. Це запобігає виконанню коду в наступних блоках case.
Якщо жодне значення не відповідає виразу, виконається код у блоці default (якщо він є).

За наявності блоку default його слід розташовувати останнім у блоці коду з оператором switch.

//Приклад використання оператора switch:
const fruit = 'apple';

switch (fruit) {
  case 'apple':
    console.log('Apple selected');
    break;
  case 'banana':
    console.log('Banana selected');
    break;
  case 'orange':
    console.log('Orange selected');
    break;
  default:
    console.log('The fruit is unknown');
}


//Оператор break
//Після виконання коду в одному з випадків потрібно використовувати оператор break, щоб вийти з оператора switch.
//Якщо break не вказано, виконання коду продовжиться в наступному case і далі. Така поведінка називається "провалюванням" (fall-through). Якщо потрібно, щоб кілька блоків case виконували той самий код, можна опустити оператор break між ними.



Інструкція if є універсальною. Інструкції if…else і else…if використовуються, коли потрібно прописати декілька умов. Отже, ці інструкції зазвичай довші, ніж інші способи розгалужень.
Тернарний оператор краще використовувати для присвоєння або повернення значення з тіла функції. В умові тернарного оператора може бути все що завгодно: перевірка рівності / нерівності, на більше / менше, просто перевірка на будь чого.

Пам’ятай про обмеження: у нього має бути рівно 2 сценарії, не більше.

Оператор switch перевіряє тільки на сувору рівність.

Використовуючи оператор switch, завжди: 
— пам’ятай про оператор break;
— використовуй тільки 1 default, він завжди має бути останнім.


//Блокова область видимості
//Область видимості визначає, чи будуть змінні та функції доступними в певних областях коду. Під час оголошення змінної або функції, вона стає "видимою" тільки в певній частині коду. Це впливає на те, де і як можна використовувати ці змінні та функції в коді.
//Змінні або функції, які оголошені поза будь - якими блоками коду — тобто в глобальній області видимості — будуть доступні в будь - якій частині коду.Вони є глобальними змінними.
// Глобальна змінна
const value = "I'm a global variable";

if (true) {
	// Можна звернутися до глобальної змінної
  console.log(value); // "I'm a global variable"
}

// Можна звернутися до глобальної змінної
console.log(value); // "I'm a global variable"


//Змінна value оголошена в глобальній області видимості, тобто поза будь-яким блоком коду, у нашому випадку поза тілом інструкції if. Вона буде доступна в будь-якому місці після оголошення.
//Будь-яка конструкція, що використовує фігурні дужки {} (умови, функції, цикли тощо) створює нову локальну блочну область видимості. Змінні, оголошені в цій області видимості, можуть бути використані тільки всередині цього блоку коду. Це локальні змінні.

if (true) {
  // Локальна змінна
	const value = "I'm a local variable";
  console.log(value); // "I'm a local variable"
}
// Помилка: локальну змінну не видно за межами блоку
console.log(value); // ReferenceError: value is not defined
//Змінна value оголошена в тілі інструкції if, тобто в локальній області видимості, обмеженій тілом блоку if. Ця змінна буде доступна лише всередині блоку if, і спроба звернення до неї поза блоком if викликає помилку.



//Логічні оператори
//Перетворення типів: логічне
// Логічне перетворення типів означає приведення значення будь-якого типу даних у логічне (булеве) значення true або false. Існує кілька правил, які визначають, які значення перетворюються на true, а які на false.
// Ці правила працюють:
// як для явного перетворення типів за допомогою функції Boolean(),
// так і для неявного в умовних операціях, наприклад, у конструкціях if чи логічних операторах.
// Логічні значення
// Логічні значення true та false залишаються незмінними.
console.log(Boolean(true)); // true
console.log(Boolean(false)); // false


//Числа
// Число 0, значення NaN, null і undefined завжди перетворюються на false. Усі інші числа перетворюються на true.
console.log(Boolean(NaN)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(0)); // false
console.log(Boolean(3.14)); // true
console.log(Boolean(-10)); // true


//Рядки
// Порожній рядок ("") приводиться до false. Будь-які інші не пусті рядки приводяться до true.
Запам’ятай 6 випадків, які приводяться до false:
1. 0
2. ""
3. Nan
4. null
5. undefined
6. false


//Логічне «І»
// Логічні оператори використовуються для перевірки умов з кількома виразами, наприклад, в інструкції if.
// Оператор "І" (&&) наводить усі операнди до логічного типу (true або false) і повертає значення одного з них. Дозволяє перевірити, чи виконані всі умови у виразі.
//Обчислення оператора відбувається зліва направо.
expression1 && expression2


//У наступних прикладах обидва операнди перетворюються на true. Обчислення відбуваються зліва направо, тому результатом буде значення правого операнда.
console.log("hello" && 5); // 5
console.log(5 && "hello"); // "hello"

console.log("mango" && "poly"); // "poly"
console.log("poly" && "mango"); // "mango"

console.log(3 && true); // true
console.log(true && 3); // 3



//А ось у цьому прикладі один із операндів буде приведений до false, отже, результатом буде хибний операнд.



console.log("hello" && 0); // 0
console.log(0 && "hello"); // 0

console.log(3 && false); // false
console.log(false && 3); // false

console.log(0 && ""); // 0
console.log("" && 0); // ""



//У прикладі “hello” && 0 лівий операнд приводиться до true, а правий до false, тому результатом виразу буде значення правого операнда, який першим був приведений до false, тобто 0.
//У приклад 0 && “hello” лівий операнд приводиться до false, тому правий операнд не буде обчислюватися. Результатом виразу буде значення лівого операнда, який першим був приведений до false, тобто 0.


//На практиці логічні операції застосовуються для перевірки множинних умов.
//Варто зазначити, що якщо операндами є вирази, то спочатку вони обчислюються, а потім їх результати будуть порівнюватися оператором &&.



const a = 20;
console.log(a > 10 && a < 30); // true && true -> true

const b = 50;
console.log(b > 10 && b < 30); // true && false -> false
console.log(b > 80 && b < 120); // false && true -> false



//У прикладі вище змінна a має одночасно задовольняти дві умови: бути 1) більшою за 10, але 2) меншою за 30. Перевірку одночасного виконання двох умов ми робимо за допомогою оператора &&. Спочатку обчислюємо вирази в операндах.

//Логічне «АБО»
//Оператор "АБО" (||) перетворює всі операнди до логічного типу (true або false) і повертає значення одного з них.
//Дозволяє перевіряти, чи є хоча б один із операндів "істинним”.
//Обчислення оператора відбувається зліва направо.
expression1 || expression2

//Якщо хоча б один із операндів можна перетворити на true, результатом логічного «АБО» буде цей операнд.
console.log(true || false); // true
console.log(false || true); // true

console.log(5 || false); // 5
console.log(false || 5); // 5

console.log("hello" || 0); // "hello"
console.log(0 || "hello"); // "hello"
//Як тільки логічний оператор “АБО” знайшов операнд, який перетворюється на true, він зупиняється та повертає його значення. Якщо до істини було перетворено перший операнд, то другий навіть не буде оцінюватися. Це може мати практичне застосування, особливо коли другий операнд є виразом, який має високу вартість обчислення.
console.log(5 || 3); // 5
console.log(3 || 5); // 3

console.log("mango" || "poly"); // "mango"
console.log("poly" || "mango"); // "poly"
//Якщо всі операнди перетворюються на false, результатом буде значення крайнього правого операнда.
console.log(0 || false); // false
console.log(false || 0); // 0

console.log(null || ""); // ""
console.log("" || null); // null
//Оператор "АБО" замикається на вірному операнді і повертає значення операнда, на якому запнувся, або значення крайнього правого операнда. Якщо лівий операнд був перетворений на true, правий операнд не обчислюється.
//На практиці оператор «АБО» також використовується для перевірки множинних умов.
const a = 5;
console.log(a < 10 || a > 30); // true || false -> true

const b = 50;
console.log(b < 10 || b > 30); // false || true -> true

const c = 20;
console.log(c - 20 || c * 2); // 0 || 40 -> 40



//Логічне «НІ»
//Усі оператори, які ми розглядали раніше, були бінарними. Бінарні оператори містять два операнди: лівий і правий.
//Логічне «НІ» (!) — це унарний оператор — він виконує операцію над одним операндом праворуч.
!expression
//Логічне «НІ» приводить операнд до логічного значення (true або false) і потім заперечує (інвертує) його, тобто заміняє на протилежне: true —> false, а false —> true.
console.log(!true); // false
console.log(!false); // true
console.log(!3); // !3 -> !true -> false
console.log(!"Mango"); // !"Mango" -> !true -> false
console.log(!0); // !0 -> !false -> true
console.log(!""); // !"" -> !false -> true
console.log(!null); // !null -> !false -> true
//На практиці логічне заперечення використовується для перевірки від зворотного. Наприклад, можна дозволити написати повідомлення в чаті, лише якщо користувач не заблокований.





//Методи рядків
//Дані мають набір властивостей і методів, до яких можна звертатися в коді. Цей набір називається інтерфейсом. Використання властивостей і методів дозволяє нам отримувати інформацію про сутності та виконувати операції з ними.
//Властивості
//У попередніх розділах ми вже познайомилися з властивостями.
//Щоб добре розрізняти властивості та методи, варто згадати, що властивості — це описові характеристики сутності. У прикладі з кавою — це колір, кількість цукру, температура. Наприклад, у програмуванні рядок має властивість length, яка повертає кількість символів у рядку. Для доступу до властивості використовується синтаксис із крапкою:
objectName.property
//Щоб отримати довжину рядка, використовується властивість length:
const message = "JavaScript is awesome";
console.log(message.length); // 21

//Методи
//Методи — це дії, які можна виконати із сутністю, такі як додати цукор чи підігріти. У програмуванні дані також заздалегідь мають певні методи, які дозволяють виконувати різні операції, наприклад, перетворення рядка в різний регістр.
//Виклик методу дуже схожий на доступ до властивості, але наприкінці додаються круглі дужки, як при виклику функції:
objectName.method()

//Ось приклад використання (виклику) методу toUpperCase() для перетворення рядка у верхній регістр:
const message = "JavaScript is awesome";
console.log(message.toUpperCase()); // "JAVASCRIPT IS AWESOME"
//Методи та властивості не можуть існувати самостійно без сутності, частиною якої вони є. Не можна викликати метод рядка trim() без рядка, не можна отримати значення властивості length без рядка або масиву.

//Метод slice()
Метод slice() використовується для створення копії частини або всього рядка без зміни оригінального рядка. Він дозволяє витягувати підрядок з вихідного рядка, вказуючи початковий та кінцевий індекси.
//Синтаксис методу slice() виглядає так:
str.slice(startIndex, endIndex)
де:
str — вихідний рядок, з якого робитиметься копія.
startIndex — індекс, з якого починається копіювання елементів рядка.
endIndex — індекс, до якого (не включаючи) йде копіювання елементів рядка.
//Метод slice() копіює підрядок із вихідного рядка, починаючи з індексу startIndex і до (не включаючи) індексу endIndex, і повертає цю копію як новий рядок.

const fullName = "Jacob Mercer";
console.log(fullName.slice(0, 4)); // 'Jaco'
console.log(fullName.slice(3, 9)); // 'ob Mer'
console.log(fullName.slice(0, fullName.length)); // 'Jacob Mercer'


//Параметр endIndex є необов'язковим.
//Якщо endIndex не вказаний, витягуються всі елементи до кінця рядка.

const fullName = "Jacob Mercer";
console.log(fullName.slice(1)); // 'acob Mercer'
console.log(fullName.slice(3)); // 'ob Mercer'

//Якщо викликати метод slice() без аргументів, він створює точну копію рядка і повертає її.
const fullName = "Jacob Mercer";
console.log(fullName.slice()); // 'Jacob Mercer'

//Результат виклику методу slice() можна зберігати в змінній для подальшого використання.
const fullName = "Jacob Mercer";
const firstName = fullName.slice(0, 5);
const lastName = fullName.slice(6);

console.log(fullName); // "Jacob Mercer"
console.log(firstName); // "Jacob"
console.log(lastName); // "Mercer"

//Метод slice() корисний, коли потрібно отримати певну частину рядка або створити копію для подальшого використання, не змінюючи вихідний рядок.



//Методи toLowerCase() і toUpperCase()
//Методи рядків toLowerCase() та toUpperCase() використовуються для зміни регістру символів у рядку. Обидва методи не змінюють вихідний рядок, а повертають новий рядок у відповідному регістрі.
//Метод toLowerCase() повертає новий рядок, у якому всі символи вихідного рядка перетворені в нижній регістр.

const message = "Welcome to Bahamas!";
console.log(message.toLowerCase()); // "welcome to bahamas!"
console.log(message); // "Welcome to Bahamas!"

//Метод toUpperCase() повертає новий рядок, у якому всі символи вихідного рядка перетворені у верхній регістр.

const message = "Welcome to Bahamas!";
console.log(message.toUpperCase()); // "WELCOME TO BAHAMAS!"
console.log(message); // "Welcome to Bahamas!"



//Метод includes()
//Метод рядків includes() використовується для перевірки наявності підрядка у рядку. Він повертає логічне значення true, якщо підрядок знайдено, і false, якщо підрядок відсутній.
//Синтаксис методу includes() виглядає так:
str.includes(substring)
де:
str — вихідний рядок, у якому ми шукаємо підрядок;
substring — підрядок, який ми хочемо знайти у вихідному рядку.


//Приклад використання методу includes():
const username = 'Jacob Mercer';

console.log(username.includes('Jacob')); // true
console.log(username.includes('John')); // false
console.log(username.includes('Mercer')); // true
console.log(username.includes('Doe')); // false
//Регістр символів у рядку й підрядку має значення. Літера a, наприклад, не дорівнює літері A.
const username = 'Jacob Mercer';

console.log(username.includes('Jacob')); // true
console.log(username.includes('jacob')); // false
console.log(username.includes('Mercer')); // true
console.log(username.includes('mercer')); // false

//Метод includes() корисний, коли нам необхідно виконати зазначені дії за умови, коли рядок містить певний підрядок.

const message = "Please buy our stuff!";
const hasSpam = message.includes("buy");

if (hasSpam) {
  console.log("Warning: This message contains forbidden words.");
} else {
  console.log("You can safely open this message.");
}

//У цьому прикладі ми перевіряємо, чи містить змінна message підрядок "buy".
//Якщо це так, виводиться повідомлення з попередженням про вміст заборонених слів. В іншому разі відображається повідомлення про те, що повідомлення можна відкривати безпечно.


//Методи startsWith() і endsWith()
//Методи startsWith() і endsWith() призначені для перевірки початку й закінчення рядка відповідно. Вони повертають булеве значення true або false, залежно від того, чи відповідає початок або кінець рядка заданому значенню.
//Метод startsWith()
//Метод startsWith() перевіряє, чи починається рядок із зазначеного підрядка.
str.startsWith(substr)
//substr — це рядок, з якого має починатися вихідний рядок.
//Приклад:
const str = "Hello, world!";

console.log(str.startsWith("Hello")); // true
console.log(str.startsWith("hello")); // false (метод чутливий до регістру)



//Метод endsWith()
//Метод endsWith() перевіряє, чи закінчується рядок вказаним підрядком.
str.endsWith(substr)
//Він також приймає аргументом підрядок, присутність якого потрібно перевірити.
//Приклад:
const str = "Hello, world!";

console.log(str.endsWith("world!")); // true
console.log(str.endsWith("World!")); // false (метод чутливий до регістру)


//Зверни увагу!
//Обидва методи чутливі до регістру символів. Це означає, що під час порівняння підрядка з вихідним рядком регістр символів має збігатися. Якщо в ці методи не передати аргумент, то він повертає false.


//Метод indexOf()
//Метод indexOf() використовується для пошуку першого входження підрядка в рядок. Він повертає:
//індекс першого входження (індекс першого символу) підрядка, якщо він знайдений або
//-1, якщо підрядок не виявлено
str.indexOf(substr)
//str — вихідний рядок, у якому потрібно виконати пошук;
//substr — рядок, який потрібно знайти у вихідному рядку.
const message = "Welcome to Bahamas!";
const index = message.indexOf("to");
console.log(index); // 8


//У цьому прикладі у нас є рядок message. Ми хочемо знайти перше входження підрядка "to". Метод indexOf() виконує пошук у рядку і повертає 8 — індекс першого входження "to".
//Якщо підрядок не знайдено, метод indexOf() поверне -1:
const message = "Welcome to Bahamas!";
const index = message.indexOf("hello");
console.log(index); // -1

//Метод indexOf() корисний, коли тобі потрібно перевірити, чи містить рядок певний підрядок і отримати його індекс, якщо його знайдено. Цей метод в аргументи може приймати рядок або число. Якщо в аргументах буде число, то воно автоматично перетвориться у рядок. А якщо нічого не передати, то поверне число -1.



//Метод trim()
//Метод trim() використовується для видалення початкових і кінцевих пробілів із рядка.
//Це дозволяє "очистити" рядок від зайвих пробілів, наприклад під час обробки введення тексту користувачем в елементи форми, видаливши зайві пробіли, які могли бути додані випадково.
str.trim()

//

const input = " JavaScript is awesome!    ";
const trimmedInput = input.trim();
console.log(trimmedInput); // "JavaScript is awesome!"
console.log(input); // " JavaScript is awesome!    "



//У цьому прикладі метод trim() видаляє пробіли на початку та наприкінці рядка, залишаючи тільки текст "JavaScript is awesome!".
//Зверни увагу!
//Метод trim() не змінює вихідний рядок, а повертає новий рядок без початкових і кінцевих пробілів.




//Цикли
//Типове завдання у програмуванні — виконання однотипної дії багато разів, наприклад вивести клієнтів зі списку один за одним або перебрати суми зарплат і для кожної виконати однаковий код. Саме для багаторазового повторення однієї частини коду використовуються цикли.



//Цикл — керуюча конструкція, призначена для організації багаторазового виконання набору інструкцій.
//Тіло циклу — послідовність інструкцій, призначена для багаторазового виконання.
//Ітерація — одиничне виконання тіла циклу.
//Умова виходу — вираз, що визначає, чи буде в черговий раз виконуватися ітерація, або цикл завершиться.
//Цикл while
//Конструкція while створює цикл, який виконує блок коду в тілі циклу, поки умова для виходу оцінюється як true.
while (condition) {
  statement // код, тіло циклу
}
//Умова обчислюється перед кожною ітерацією циклу.
//Якщо умова оцінюється як true, виконується код у тілі циклу (одна ітерація)
//Якщо умова оцінюється як false, виконання циклу переривається і скрипт продовжує виконувати інструкції після циклу

//Цикл while — це цикл з передумовою, тобто він виконується доки істинна певна умова, зазначена перед його початком. Цю умову перевіряють до виконання тіла циклу, тому тіло може бути не виконано жодного разу, якщо умова від самого початку хибна.
//Розгляньмо приклад з лічильником:
let count = 0;

while (count < 10) {
  console.log(`Count: ${count}`);
  count += 1;
}

//У цьому прикладі у нас є змінна count, яка збільшується з кожною ітерацією.
//Цикл while виконуватиметься доки count менше 10. Щойно count стане рівним або більшим за 10, умова стане хибною, і цикл завершиться.

//Важливо дбати про те, щоб умова циклу while зрештою стала хибною, щоб уникнути нескінченного виконання.


//Цикл do…while
//У JavaScript існує ще один тип циклу while — це do...while.
//Цикли while і do...while працюють схожим чином, але мають одну ключову відмінність. Під час використання циклу do...while код у тілі циклу виконується принаймні один раз, навіть якщо умова не виконується з самого початку.
do {
   statement // код, який буде виконуватися
} while (condition);

// Блок коду всередині do виконується в перший раз незалежно від виконання умови.
// Потім, після кожної ітерації, перевіряється умова. Якщо умова оцінюється як true, цикл продовжує виконуватися; якщо — як false, цикл завершується.


// Цикл for
// Цикл for також дозволяє виконувати код, що повторюється, багато разів. На відміну від циклів while і do…while, цикл for має змінну-лічильник. Змінна-лічильник оголошується за допомогою ключового слова let (оголошення через const видасть помилку). На кожній ітерації після виконання коду з тіла циклу вона змінює своє значення від заданого початкового до кінцевого з певним кроком.


for (Ініціалізація; Умова; Пост-вираз) {
  // Тіло циклу
}

// Ініціалізація — виконується один раз перед початком циклу. Тут оголошується змінна-лічильник і вказується її початкове значення.
// Умова — це вираз, який оцінюється перед кожною ітерацією (повторенням) циклу. Якщо умова перетворюється на**true**, то виконується тіло циклу. Якщо умова перетворюється на false, то цикл завершується.
// Пост-вираз — це вираз, який виконується в кінці кожної ітерації циклу, перед перевіркою умови. Використовується для оновлення значення змінної-лічильника.
// Тіло циклу — це блок коду, який буде виконуватися на кожній ітерації циклу, якщо умова перетворюється на true.



// Напишемо фукнцію яка підсумовує всі числа від 0 до заданого числа і повертає результат:

function sumUpTo(number) {
  let sum = 0;

  for (let i = 0; i <= number; i += 1) {
    sum += i;
  }

  return sum;
}
console.log(sumUpTo(5)); // 15
console.log(sumUpTo(10)); // 55
console.log(sumUpTo(0)); // 0


// Як працює функція:
// 1) Приймає один параметр – number, який визначає, до якого числа потрібно підсумовувати.
// 2) Оголошує змінну sum і встановлює її в 0 – у ній накопичуватиметься сума.
// 3) Запускає цикл for:
// for (let i = 0; i <= number; i += 1) {
// i починається з 0.
// Працює, поки i <= number.
// Після кожної ітерації i збільшується на 1.
// 4) Додає поточне значення i до sum:
// sum += i;
// 5) Після завершення циклу повертає підсумоване значення sum у зовнішній код.




// Інкремент і декремент
// Інкремент (++) і декремент (--) — це операції, які відповідно збільшують або зменшують значення числової змінної на одиницю і одразу ж зберігають оновлене значення у цій змінній. Існують два види інкременту та декременту: префіксний і постфіксний.
// Інкремент
// Префіксний інкремент (++value) спочатку збільшує значення змінної, а потім використовує нове значення у виразі.
let x = 5;
const y = ++x;
console.log(x); // 6
console.log(y); // 6




// Постфіксний інкремент (value++) спочатку використовує поточне значення змінної у виразі, а потім виконує збільшення значення.
let x = 5;
const y = x++;
console.log(x); // 6
console.log(y); // 5




// Декремент
// Префіксний декремент (--value) спочатку зменшує значення змінної, а потім використовує нове значення у виразі.
let x = 5;
const y = --x;
console.log(x); // 4
console.log(y); // 4




// Постфіксний декремент (value--) спочатку використовує поточне значення змінної у виразі, а потім виконує зменшення значення.
let x = 5;
const y = x--;
console.log(x); // 4
console.log(y); // 5




// Ці операції корисні, коли тобі потрібно змінювати значення змінних одразу на одиницю, що може бути важливо, наприклад, при створенні лічильників у циклах, замість комбінованих операторів += і -=.
for (let i = 0; i <= 5; i++) {
  console.log(i);
}

// У прикладі циклу for вище, змінна i ініціалізується значенням 0, і цикл виконується доти, доки i менше або дорівнює 5. Після кожної ітерації значення i збільшується на 1. У результаті в консоль будуть виведені числа від 0 до 5.


// Оператор break
// Оператор break використовується в циклі для переривання його виконання. Коли оператор break зустрічається всередині циклу, виконання циклу негайно припиняється, і керування передається до наступної інструкції після циклу.
// Оператор break зазвичай використовується разом з умовними операторами або операторами порівняння всередині циклу, щоб перевіряти певну умову і, якщо вона виконується, переривати виконання циклу.
// Ось приклад використання оператора break у циклі for:

for (let i = 0; i < 10; i+=1) {
  console.log(i);

  if (i === 5) {
    console.log('Met the number 5, interrupt the execution of the cycle');
    break;
  }
}

console.log('Log after cycle');

// У цьому прикладі цикл for мав би виконуватися, доки значення змінної i менше 10. Але в тілі циклу є умова if (i === 5), яка перевіряє, чи дорівнює значення i числу 5. Коли ця умова стає істинною, тіло if виконується і застосовується оператор break, і виконання циклу припиняється. Таким чином, у консоль будуть виведені числа від 0 до 5 (включно), а цикл завершиться.



// Оператор break і функції
// Коли оператор break зустрічається всередині циклу, виконання циклу негайно припиняється, і керування передається на наступну інструкцію за циклом, навіть якщо цикл знаходиться всередині функції. Тобто оператор break не припиняє виконання функції, а тільки перериває цикл.

function findNumber(max, target) {
	console.log("Log in the body of the function before the cycle");

  for (let i = 5; i <= max; i += 1) {
    console.log("Current counter value i:", i);

    if (i === target) {
      console.log(`Found the number $ {target}, interrupt the cycle`);
			break;
    }
  }

  console.log("Log in body function after cycle");
}

findNumber(10, 6);
console.log("Log after exiting function");



// Для того щоб переривати виконання одразу циклу і функції і повернути результат у зовнішній код, є оператор return.
// У прикладі шукаємо число 6. Щойно виконається умова if, робимо повернення, яке перерве виконання циклу і функції.
function findNumber(max, target) {
	console.log("Log in the body of the function before the cycle");

	for (let i = 5; i <= max; i += 1) {
	    console.log("Current counter value i:", i);
	
	    if (i === target) {
	      console.log(`Found the number $ {target}, we make a return, interrupting the loop and function`);
				return i;
	    }
	  }

  // Цей console.log не виконується
  console.log("Log in body function after cycle");
}

const result = findNumber(10, 6);
console.log("Log after exiting function");
console.log(`Result of function execution ${result}`);