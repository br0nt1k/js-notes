//Інструкція (statement) — це пов'язаний набір слів і символів із синтаксису мови, які об'єднуються, щоб висловити одну ідею, тобто одну інструкцію для машини.
//Розгляньмо приклад інструкції нижче.
a = b * 2; //Інструкція



//Суворий режим (англ. strict mode) у JavaScript — це спеціальний режим виконання коду, який дає змогу переводити скрипт у режим повної відповідності сучасному стандарту. Це запобігає певним помилкам, наприклад, використанню небезпечних і застарілих конструкцій, що робить код надійнішим та дозволяє легше його підтримувати.Щоб увімкнути суворий режим, потрібно додати директиву 'use strict'; на початок скрипта. Наприклад:
'use strict';
// Код у суворому режимі



//Виведення даних
//об вивести дані в консоль розробника використовується метод 
console.log();
console.log("JavaScript is awesome!");
console.log(10);



//Змінна — це контейнер, який використовується для зберігання даних.
const // змінна яку не можна перевизначити після оголошення 
let // змінна яку можна перевизначити після оголошення
const age = 20;
let username;
console.log(username); // undefined
username = "Mango";
console.log(username); // "Mango"



//Назви змінних треба писати в такому вигляді camelCase нотації
user, getUserData, isActive, activeGuestCount



//Типи даних

//Number-число
const ageVisitor = 20;
const salary = 3710.84;

//String-рядок
const usernamePassword = 'Mango995';
const description = "JavaScript is awesome!";

//Boolean-Логічний тип даних (Boolean) має лише два значення: true і false
const isModalOpen = true;
const isLoggedIn = false;



//Спеціальні значення
//У JavaScript існують два спеціальні значення: null і undefined. Обидва означають відсутність значення.
//Хоча обидва значення null і undefined позначають відсутність значення, вони мають трохи різні семантики використання.
// — null використовується для явної вказівки порожнього значення (точно відомо, що значення немає).
// — undefined вказує на невизначеність значення змінної.


//Оператор typeof
//Оператор typeof використовується для визначення типу даних значення або виразу.
typeof operand
//Замість operand ти вказуєш змінну, літерал або вираз, тип якого ти хочеш визначити. Результатом оператора typeof буде рядок, який вказує тип даних.
const quantity = 17;
console.log(typeof quantity); // виведе "number"

const message = "JavaScript is awesome!";
console.log(typeof message); // виведе "string"

const isSidebarOpen = false;
console.log(typeof isSidebarOpen); // виведе "boolean"

let username;
console.log(typeof username); // виведе "undefined"

let status = null;
console.log(typeof status); // виведе "object"


//Зверни увагу на перевірку типу значення null. Важливо розуміти, що null насправді є примітивним значенням, а не об'єктом.Коли ми використовуємо оператор typeof для перевірки типу значення null, він повертає рядок object. Це може здатися дивним, оскільки null — це фактично відсутність значення, а не об'єкт. Про це часто питають на співбесідах.Причина цього полягає в тому, що в ранніх версіях JavaScript null було розглянуто як спеціальний випадок об’єкта. Це була помилка в реалізації мови, збережена для забезпечення зворотної сумісності з існуючим кодом. Тому коли typeof застосовується до null, він повертає object, щоб зберегти цю сумісність.


//Арифметичні операції
//У JavaScript доступні різноманітні математичні оператори, які дозволяють виконувати арифметичні обчислення.
const x = 8;
const y = 5;
console.log(x + y); // 13


const x = 8;
const y = 5;
console.log(x - y); // 3


const x = 8;
const y = 5;
console.log(x * y); // 40


const x = 8;
const y = 5;
console.log(x / y); // 1.6


const x = 8;
const y = 5;
console.log(x % y); // 3


const x = 8;
const y = 5;
console.log(x ** y); // 32768


//Комбіновані оператори
//Для всіх арифметичних операторів є еквівалентні комбіновані оператори. Вони дозволяють більш компактно виконувати арифметичні операції та одночасно оновлювати значення змінної, виходячи з її попереднього значення.
// Ось список арифметичних операторів та їх комбінованих еквівалентів:
Додавання: +=. Приклад: x += y еквівалентно x = x + y
Віднімання: -=. Приклад: x -= y еквівалентно x = x - y
Множення: *=. Приклад: x *= y еквівалентно x = x * y
Ділення: /=. Приклад: x /= y еквівалентно x = x / y
Остача від ділення: %=.Приклад: x %= y еквівалентно x = x % y

let age = 25;
age = age + 1;
console.log(age); // 26



//Конкатенація рядків
//Якщо застосувати оператор + до рядка та будь-якого іншого типу даних, результатом буде новий рядок, що містить об'єднання вихідних значень. Це називається конкатенація (склеювання).

const message = "Mango " + "is" + " happy";
console.log(message); // "Mango is happy"
// Рядки "Mango " і " happy" містять пробіли, щоб текст повідомлення був читабельним.

const age = 24;
const message = "Poly is " + age + " years old!";

console.log("Mango" + 55); // "Mango55"
console.log("Mango" + true); // "Mangotrue"


console.log(1 + "2"); // "12"
console.log(1 + "2" + 4); // "124"
console.log(1 + 2 + "4"); // "34"



//Перетворення типів: рядки
//Перетворення типів у JavaScript — це процес зміни значення одного типу даних на інший тип даних. Перетворення типів може відбуватися в різних ситуаціях, наприклад, під час виконання арифметичних операцій з різними типами даних або порівняння значень. У JavaScript існують два типи перетворення: явне та неявне.
//Явне перетворення типів
//Явне перетворення типів виконується програмістом і використовується за потребою. Для перетворення будь-якого значення на рядок можна використовувати вбудовану функцію String(), яка повертає результат у вигляді рядка.

//Неявне перетворення типів
//Неявне перетворення типів відбувається автоматично під час виконання операцій або обчислень. Наприклад, якщо виконується операція додавання (+) між рядком та іншим типом даних, JavaScript автоматично перетворює значення операнда на рядок і виконує конкатенацію рядків.
Ось приклади неявного перетворення всіх примітивних типів під час конкатенації рядків:
console.log("5" + 3); // "53"
console.log("5" + true); // "5true"
console.log("5" + false); // "5false"
console.log("5" + null); // "5null"
console.log("5" + undefined); // "5undefined"
//Неявне перетворення — це зручний вбудований механізм JavaScript, але іноді може викликати несподівані результати або помилки. Тому важливо бути уважним при виконанні операцій з різними типами даних і вчитися контролювати та бачити перетворення типів у коді своїх програм.


//Шаблонні рядки
//Шаблонні рядки — це синтаксис, який полегшує об'єднання статичного тексту з динамічним (тобто текстом, що містить змінні, обчислення тощо). Шаблонні рядки дозволяють уникати користування заплутаною конкатенацією та роблять код більш читабельним.
//Шаблонні рядки огортаються зворотними лапками (англ. backticks) (``)
//Шаблонні рядки дозволяють підставляти значення змінних безпосередньо всередині рядка за допомогою синтаксису інтерполяції ${змінна}.

const guestName = "Mango";
const roomNumber = 207;
const greeting = `Welcome ${guestName}, your room number is ${roomNumber}!`;
console.log(greeting); // "Welcome Mango, your room number is 207!"

//Код шаблонних рядків є більш читабельним.


//Довжина рядка
//Властивості — це описові характеристики сутності.

Для доступу до властивості(property) сутності(objectName) використовується синтаксис із крапкою:
сутність.властивість

//Довжина рядка визначається кількістю символів у ньому. Щоб дізнатися довжину рядка, використовується вбудована властивість length. Щоб отримати значення цієї властивості, необхідно звернутися до неї через крапку після імені змінної чи рядкового літералу.
Наприклад, щоб отримати довжину рядка, ми можемо використовувати властивість length таким чином:
const productName = "Repair droid";

// Якщо у змінній зберігається рядок
console.log(productName.length); // 12

// Якщо рядковий літерал
console.log("Repair droid".length); // 12



//Індексація рядків
//Рядки — це набори символів, де кожен символ має свій порядковий номер (індекс). Індексація елементів рядка починається з нуля. Перший символ має індекс 0, другий — індекс 1, третій — 2 і так далі.

//Для доступу до певного символу рядка ми використовуємо синтаксис квадратних дужок, де вказуємо індекс потрібного символу: string[index], тобто рядок[індекс].
const product = "Repair droid";
console.log(product[0]); // 'R'
console.log(product[5]); // 'r'
console.log(product[11]); // 'd'

//Отримання останнього символу рядка можливе за його індексом string[lastIndex]. Щоб знайти індекс останнього символу рядка, треба від довжини цього рядка відняти одиницю string.length - 1
const product = "Repair droid";
const lastElementIndex = product.length - 1;
console.log(product[lastElementIndex]); // 'd'

//Для доступу до останнього символу рядка без створення проміжної змінної ми можемо вставити вираз (product.length - 1) безпосередньо у квадратні дужки при зверненні до елемента.
const product = "Repair droid";
console.log(product[product.length - 1]); // 'd'


//Незмінність рядків
//Коли рядок створюється, він зберігає своє значення і стає незмінним. Це означає, що не можна замінити окремі символи всередині рядка.
//Уяви, що маємо рядок "Droid". Ми не можемо змінити окремий символ у цьому рядку, наприклад, замінити 'o' на 'O'. Спроба надання нового значення елементу рядка не призведе до зміни вихідного рядка.
let product = "Droid";
console.log(product); // "Droid"

// Це не має жодного ефекту
product[2] = "O";
console.log(product); // "Droid"



//Оператори порівняння
//Оператори порівняння використовуються для порівняння двох значень і повертають булеве значення (true або false) залежно від результату порівняння.
Ось деякі основні оператори порівняння:

Оператор > (більше) — повертає true, якщо лівий операнд більше правого. В іншому разі повертає false .

Оператор < (менше) — повертає true, якщо лівий операнд менше правого. В іншому разі повертає false .

Оператор >= (більше або дорівнює) — повертає true, якщо лівий операнд більше або дорівнює правому. Якщо навпаки, повертає false .

Оператор <= (менше або дорівнює) — повертає true, якщо лівий операнд менше або дорівнює правому. Якщо навпаки, повертає false .

Давай розглянемо приклади використання цих операторів:
const a = 2;
const b = 5;

console.log(a > b); // false
console.log(b > a); // true
console.log(a >= b); // false
console.log(b >= a); // true

console.log(a < b); // true
console.log(b < a); // false
console.log(a <= b); // true
console.log(b <= a); // false

//Основний принцип використання операторів порівняння полягає в тому, щоб порівнювати значення та отримувати булевий результат. Булевий результат (результат у вигляді true або false) дозволяє приймати певні рішення та контролювати поведінку програми відповідно до умов.

//Оператори рівності
//У JavaScript існують оператори рівності, які дозволяють порівнювати значення та визначати їхню рівність або нерівність.
Оператори несуворої рівності:

Оператор == (дорівнює) — порівнює два значення на рівність і повертає true, якщо значення операндів рівні. Якщо навпаки, повертає false

Оператор != (не дорівнює) — порівнює два значення на нерівність і повертає true, якщо значення операндів не рівні.Якщо навпаки, повертає false

console.log(5 == 5); // true
console.log(5 == 3); // false
console.log(5 != 3); // true
console.log(5 != 5); // false

Але є одна проблема.

Оператори несуворої рівності можуть приводити значення до різних типів, в залежності від контексту порівняння.Це може призвести до неочікуваних результатів, тому багато розробників намагаються уникати їх використання.

// Погано, бо виконується неявне приведення рядків і булевого значення до числа
console.log(5 == "5"); // true
console.log(5 != "5"); // false
console.log(1 == true); // true
console.log(1 != true); // false

//Неявне перетворення типів може призводити до помилок, особливо в розробників-початківців. Для уникнення таких проблем рекомендується використовувати оператори суворої рівності, які не виконують перетворення типів операндів.
Оператор === (сувора рівність) — порівнює два значення на рівність, повертає true, якщо значення операндів рівні та мають однаковий тип даних. В іншому випадку, повертає false

Оператор !== (сувора нерівність) — порівнює два значення на нерівність, повертає true, якщо значення операндів не рівні або мають різні типи даних.В іншому випадку, повертає false

// Добре, приведення типів не виконується
console.log(5 === 5); // true
console.log(5 === "5"); // false
console.log(5 !== "5"); // true
console.log(5 !== 5); // false
console.log(1 === true); // false
console.log(1 !== true); // true

//На відміну від несуворих операторів, вирази 5 === "5" і 1 === true повернуть false, тому що операнди мають різні типи.

//Перетворення типів: числа
//У деяких операціях виконується явне або неявне перетворення значень операндів до числа.
//Для явного перетворення будь-якого значення в число можна використовувати вбудовану функцію 
Number()// яка повертає результат у вигляді числа.
console.log(Number("5")); // 5
console.log(Number(true)); // 1
console.log(Number(false)); // 0
console.log(Number(null)); // 0


При перетворенні до числа:
true завжди приводиться до 1;
false, null і "" завжди приводяться до 0.

//Якщо неможливо привести значення до числа, результатом перетворення буде спеціальне значення NaN (Not a Number). Ось кілька прикладів, коли результатом перетворення буде NaN.
console.log(Number(undefined)); // NaN
console.log(Number("Jacob")); // NaN
console.log(Number("25px")); // NaN

//Арифметичні операції (+, -, *, /) виконують неявне перетворення типів.
console.log("5" * 2); // 10
console.log("10" - 5); // 5
console.log(5 + true); // 6
console.log(5 - true); // 4


//Якщо у виразі присутній хоча б один із операндів з типом рядка, то обидва операнди приводяться до чисел. Це відбувається у всіх арифметичних операціях, окрім додавання. Пам’ятай, що + біля рядкових операндів викликає їх з'єднання (конкатинацію).Для всіх інших типів операндів та операцій виконується перетворення операндів до числа.


//У разі використання операторів порівняння (<, >, <=, >=) також виконується неявне перетворення типів. Якщо операнди різних типів, то перед порівнянням вони приводяться до числа.
console.log("10" > 5); // true
console.log(10 > "5"); // true
console.log(5 > true); // true
console.log(5 < true); // false
console.log("5" < true); // false


//Перетворення рядків у числа
Метод Number.parseInt()//приймає 2 аргументи:
//Рядок. Якщо аргумент не є рядком, то він буде спочатку перетворений у рядок
//Система числення, до якої відноситься рядок (не обов’язковий аргумент, за замовчуванням десяткова система). Наприклад, для десяткової системи буде 10, для шістнадцяткової - 16 тощо..
//Метод аналізує рядок зліва направо, видаляючи пробіли на початку і перетворюючи допустимі символи у число до тих пір, поки не зіткнеться з першим недопустимим символом. Після цього аналіз припиняється, і вже перетворене ціле число повертається.
console.log(Number.parseInt("5")); // 5 
console.log(Number.parseInt("5.5")); // 5 
console.log(Number.parseInt("5cm")); // 5 
console.log(Number.parseInt("12qwe74")); // 12 
console.log(Number.parseInt("12.46qwe79")); // 12 
console.log(Number.parseInt("cm5")); // NaN 
console.log(Number.parseInt("")); // NaN 
console.log(Number.parseInt("qweqwe")); // NaN

//Якщо перші символи рядка не можуть бути перетворені на число, або рядок порожній чи відсутній, результатом буде значення NaN (Not a Number).

Метод Number.parseFloat()//аналогічний Number.parseInt() з однієї відмінністю: перетворює рядок на число з плаваючою крапкою.
console.log(Number.parseFloat("5")); // 5
console.log(Number.parseFloat("5.5")); // 5.5
console.log(Number.parseFloat("3.14")); // 3.14
console.log(Number.parseFloat("5cm")); // 5
console.log(Number.parseFloat("5.5cm")); // 5.5
console.log(Number.parseFloat("12qwe74")); // 12
console.log(Number.parseFloat("12.46qwe79")); // 12.46
console.log(Number.parseFloat("cm5")); // NaN
console.log(Number.parseFloat("")); // NaN
console.log(Number.parseFloat("qweqwe")); // NaN

//Якщо перші символи рядка не можуть бути перетворені на число, або рядок порожній чи відсутній, результатом буде значення NaN (Not a Number).


//Арифметичні функції
//Клас Math є вбудованим класом JavaScript. Цей клас надає набір методів для виконання математичних операцій та роботи з числами. Ось кілька найбільш корисних методів, які надає клас Math:

Math.floor(num): //повертає найближче ціле число, яке є меншим або дорівнює вказаному числу num. Наприклад:
console.log(Math.floor(1.3)); // 1
console.log(Math.floor(1.7)); // 1

Math.ceil(num): //повертає найближче ціле число, яке є більшим, або дорівнює зазначеному числу num. Наприклад:
console.log(Math.ceil(1.3)); // 2
console.log(Math.ceil(1.7)); // 2

Math.round(num): //повертає значення числа після округлення до найближчого цілого. Округлення відбувається за математичними правилами, якщо десяткова частина числа менша 0.5, то округлення буде в меншу сторону, якщо 0.5 і більше — то в більшу.Наприклад:
console.log(Math.round(1.3)); // 1
console.log(Math.round(1.7)); // 2

Math.max(num1, num2, ...): //повертає найбільше число з набору переданих чисел. Наприклад:
console.log(Math.max(20, 10, 50, 40)); // 50

Math.min(num1, num2, ...): //повертає найменше число з набору переданих чисел. Наприклад:
console.log(Math.min(20, 10, 50, 40)); // 10

Math.random(): //повертає випадкове число в діапазоні від 0 (включно) до 1 (за винятком). Наприклад:
console.log(Math.random()); // випадкове число між 0 і 1, наприклад 0.2 ... 0.9166353649342294

//Це лише деякі методи класу Math. Він також надає методи для тригонометричних функцій, логарифмів та інших математичних операцій. Ви можете звернутися до документації JavaScript для отримання повного списку методів класу Math і більш детального опису кожного з них.


//Дробове число
//При виконанні операцій з дробовими числами можуть виникати неточності через внутрішнє представлення чисел у пам'яті комп'ютера.
//Наприклад, результат 0.1 + 0.2 не дорівнює 0.3. Число 0.1 у двійковій системі числення, яку використовує комп'ютер — це нескінченний дріб. Двійкове значення нескінченних дробів зберігається лише до певного знака, тому виникає неточність. При додаванні 0.1 і 0.2 дві неточності складаються, виходить незначна, але все ж таки помилка в обчисленнях.
console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2); // 0.30000000000000004

//Як виправити цю проблему?
//Залежно від необхідної точності, можна використовувати різні підходи.

Підхід 1.

//Помножити числа на досить велике число (наприклад, 10 або 100).
//Виконати додавання.
//Розділити результат на те саме число, щоб повернути його до початкового масштабу.
console.log(0.1 * 10 + 0.2 * 10); // 3
console.log((0.1 * 10 + 0.2 * 10) / 10); // 0.3

Підхід 2.

//Використовувати метод числа toFixed() для округлення результату до певної кількості знаків після крапки.
console.log((0.1 + 0.2).toFixed(1)); // "0.3"
console.log((5).toFixed(2));  //  ”5.00”
console.log((8.762195).toFixed(4));  //  “8.7622”

Метод toFixed() //повертає рядок, що представляє число із зазначеною кількістю знаків після крапки. Таким чином, ми можемо отримати заокруглений результат з необхідною точністю.



//Основи функцій
//Оголошення та виклик функції
//Функція — це незалежний блок коду, який виконує певну задачу з різними початковими значеннями.
//Оголошення функції
//Оголошення функції має таку структуру:
//Ключове слово function
//Ім'я функції — це дієслово, що відповідає на питання "Що зробити?"
//Пара круглих дужок ()
//Тіло функції у фігурних дужках { }

function doStuff() {
  // Тіло функції
  console.log('Log inside multiply function');
}

//Тіло функції міститься у фігурних дужках {}. Воно містить інструкції, які потрібно виконати під час виклику функції. Ці інструкції можуть включати оператори, умовні конструкції, цикли та інші функції.



//Виклик функції
//Коли функцію потрібно виконати, вона викликається за допомогою її імені та пари круглих дужок.
// Оголошення функції multiply
function doStuff() {
  // Тіло функції
  console.log('Log inside multiply function');
}

// Виклики функції multiply
doStuff(); // 'Log inside multiply function'



//Параметри та аргументи
//У круглих дужках після імені функції вказуються параметри. Параметри є перерахуванням даних, які очікує функція під час виклику.

// Оголошення параметрів x, y, z
function multiply(x, y, z) {
  console.log(`Result: ${x * y * z}`);
}

//Параметри — це локальні змінні, доступні лише всередині тіла функції.
//араметри розділяються комами. Функція може мати будь-яку кількість параметрів або не мати їх взагалі, у такому випадку вказуються просто порожні круглі дужки.
//Під час виклику функції в круглих дужках можна передати аргументи, які є значеннями для оголошених параметрів функції.
// Оголошення параметрів x, y, z
function multiply(x, y, z) {
  console.log(`Result: ${x * y * z}`);
}

// Передача аргументів
multiply(2, 3, 5); // "Result: 30"
multiply(4, 8, 12); // "Result: 384"
multiply(17, 6, 25); // "Result: 2550"
//Отже, у прикладі вище маємо параметри x, y, z.
//Під час кожного виклику функції параметр може отримувати нове значення з аргументів. Наприклад, параметр x спочатку отримав значення 2, потім 4, потім 17.
//При передачі аргументів під час виклику функції необхідно дотримуватись порядку, що відповідає порядку оголошених параметрів: значення першого аргументу буде присвоєно першому параметру, другого аргументу — другому параметру і так далі.
//Щоразу під час виклику функції параметри будуть оголошуватися заново, і їх значення в окремих викликах функції не впливатимуть один на одний.



//Повернення значення
Оператор return використовується для повернення значення з тіла функції назад у код, у місце її виклику.Коли інтерпретатор зустрічає оператор return, він негайно виходить із функції(припиняє її виконання) і повертає вказане після return значення в місце виклику функції.

function multiply(x, y, z) {
	const product = x * y * z;
  // Повертаємо результат виразу множення
  return product;
}

// Результат роботи функції можна зберегти у змінну
const result = multiply(2, 3, 5);
console.log(result); // 30


//Щоб уникнути оголошення зайвої змінної в тілі функції, можна відразу ж повертати результат виразу. Так, немає необхідності створювати окрему змінну для зберігання результату виразу.
function multiply(x, y, z) {
  return x * y * z;
}

const result = multiply(2, 3, 5);
console.log(result); // 30


//Якщо в тілі функції відсутній оператор return або він не вказує на конкретне значення, функція поверне спеціальне значення undefined.

function multiply(x, y, z) {
	const product = x * y * z;
}

const result = multiply(2, 3, 5);
console.log(result); // undefined


//При використанні оператора return всі інструкції, які йдуть на рядках після нього, в тілі функції не виконуються, оскільки виконання функції припиняється відразу після зустрічі оператора return.
function multiply(x, y, z) {
  console.log('The code before return is executed as usual');

  return x * y * z;

  console.log('This code is never executed because it is after return');
}
console.log(multiply(2, 3, 5)); // 30



//Порядок виконання коду
//Коли інтерпретатор зустрічає виклик функції, він зупиняє виконання поточного коду й починає виконувати код з тіла функції.
//Після того, як весь код у функції буде виконано, інтерпретатор повертає управління в те місце, звідки був здійснений виклик функції, і продовжує виконання коду програми, що залишився.

function multiply(x, y, z) {
  console.log(`Result: ${x * y * z}`);
}

console.log("Log before multiply execution");
multiply(2, 3, 5); // "Result: 30"
console.log("Log after multiply execution");


//Послідовність логів у консолі буде такою:
"Log before multiply execution"
"Result: 30"
"Log after multiply execution"

//Будь-яка конструкція, що використовує фігурні дужки {} (умови, цикли, функції тощо) створює нову локальну область видимості. Змінні, оголошені в локальній області видимості, можуть бути використані тільки всередині цього блоку коду.

function foo() {
	// Локальна змінна
	const value = "I'm a local variable";
	// Можна звернутися до локальної змінної
	console.log(value); // "I'm a local variable"
}

foo();
  console.log(value); // ReferenceError: value is not defined
                      // Помилка: локальну змінну не видно за межами  
                         функції

